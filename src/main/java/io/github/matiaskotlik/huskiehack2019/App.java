/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package io.github.matiaskotlik.huskiehack2019;

import io.github.matiaskotlik.huskiehack2019.ai.SentimentAnalysis;
import io.github.matiaskotlik.huskiehack2019.cryptography.Hasher;
import org.nanohttpd.protocols.http.IHTTPSession;
import org.nanohttpd.protocols.http.NanoHTTPD;
import org.nanohttpd.protocols.http.request.Method;
import org.nanohttpd.protocols.http.response.Response;
import org.nanohttpd.protocols.http.response.Status;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.UUID;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class App extends NanoHTTPD {
	private Template loginTmp;
	private Template btnTmp;

	private ComplimentStorage complimentStorage;

	private UserAccounts users;

	private Hasher hasher;

	private SessionList sessionList;

	private SentimentAnalysis sentimentAnalysis;

	private static final Pattern STATIC_PATH_PATTERN = Pattern.compile("^/static/([a-zA-Z0-9\\.\\-]+)$");
	private static final String LOCAL_DOCS_PATH = "docs/static/";

	public App(int port) {
		super(port);

		sessionList = new SessionList();

		users = new UserAccounts();

		hasher = new Hasher();

		loginTmp = getTemplate("docs/index.html");
		btnTmp = getTemplate("docs/buttonpage.html");

		complimentStorage = new ComplimentStorage();

		sentimentAnalysis = new SentimentAnalysis();
		sentimentAnalysis.sentiment("asdf");
	}

	public Session getSession(IHTTPSession ihttpSession) {
		return sessionList.getSession(getSessionId(ihttpSession));
	}

	public String getSessionId(IHTTPSession ihttpSession) {
		String id = ihttpSession.getCookies().read("session");
		id = id == null ? UUID.randomUUID().toString() : id;
		setSessionId(ihttpSession, id);
		return id;
	}

	public void setSessionId(IHTTPSession ihttpSession, String id) {
		ihttpSession.getCookies().set("session", id, Integer.MAX_VALUE);
	}

	public Map<String, String> getSessionDataMap(Session session) {
		Map<String, String> map = new HashMap<>();
		if (session.getName() != null) {
			map.put("name", session.getName());
		}
		return map;
	}

	@Override
	public Response serve(IHTTPSession ihttpSession) {
		Method method = ihttpSession.getMethod();
		String uri = ihttpSession.getUri();

		if (method.equals(Method.POST)) {
			try {
				ihttpSession.parseBody(new HashMap<>());
			} catch (IOException e) {
				System.err.println("Could not parse body");
			} catch (ResponseException e) {
				System.err.println("ResponseException when trying to parse body");
			}
		}

		Session session = getSession(ihttpSession);
		if (uri.equals("/")) {
			if (session.getName() != null) {
				return ss(btnTmp.render(getSessionDataMap(session)));
			} else {
				return ss(loginTmp.render(getSessionDataMap(session)));
			}
		} else if (uri.equals("/logout")) {
			session.setName(null);
			return redirect("/");
		} else if (uri.equals("/signin")) {
			String name = ihttpSession.getParms().get("name");
			String psw = ihttpSession.getParms().get("psw");
			if (name != null && !name.trim().equals("")
					&& psw != null && !psw.trim().equals("")) {
				name = name.trim();
				psw = psw.trim();
				Account account = users.getAccount(name);
				System.out.println("acc: " + account);
				if (account == null) {
					session.setName(name);
					String salt = hasher.genSalt();
					System.out.println("salt for " + name + " is " + salt);
					String hashed = hasher.hash(psw, salt);
					System.out.println("hashed for " + name + " is " + hashed);
					users.addAccount(new Account(name, hashed, salt));
				} else {
					System.out.println("trying to login to account " + account.getName());
					String salt = account.getSalt();
					System.out.println("salt is " + salt);
					System.out.println("hashed is "+ account.getHashed());
					System.out.println("hi is " + hasher.hash("hi", salt));
					String hash = hasher.hash(psw, salt);
					System.out.println("our hashed psw is " + hash);
					if (hasher.verify(psw, account.getHashed(), salt)) {
						session.setName(name);
					}
				}
			}
			System.out.println(session.getName());
			return redirect("/");
		} else if (uri.equals("/give")) {
			String name = ihttpSession.getParms().get("name");
			String compliment = ihttpSession.getParms().get("compliment");
			if (name != null && compliment != null) {
				System.out.println("name: " + name);
				System.out.println("accs: " + users.getAccounts());
				Account account = users.getAccount(name);
				System.out.println("acc: " + account);
				if (account != null) {
					System.out.println("analyzing " + compliment);
					if (sentimentAnalysis.sentiment(compliment)) {
						complimentStorage.store(name, compliment);
						return ss("Your compliment was sent! Here is your code: 100111");
					} else {
						return ss("NO");
					}
				} else {
					return ss("That user does not exist. Maybe you spelled it wrong?");
				}
			}
		} else if (uri.equals("/get")) {
			String name = session.getName();
			System.out.println("getting compliment for name: " + name);
			if (name != null) {
				String compliment = complimentStorage.get(name);
				return compliment == null ? ss("You have no compliments.") : ss(compliment);
			}
		} else if (uri.equals("/list")) {
			StringBuilder listBuilder = new StringBuilder().append("[");
			users.getAccounts().keySet().forEach(user -> listBuilder.append("\"").append(user).append("\","));
			return ss(listBuilder.substring(0, listBuilder.length() - 1) + "]");
		} else if (uri.startsWith("/static/")) {
			Matcher m = STATIC_PATH_PATTERN.matcher(uri);
			if (m.find()) {
				String name = m.group(1);
				if (name != null) {
					return FileResponse(LOCAL_DOCS_PATH + name);
				}
			}
		} else if (uri.equals("/fail")) {
			return FileResponse("docs/fail.html");
		}
		return Response.newFixedLengthResponse("Error 404 File not Found");
	}

	public Response FileResponse(String path) {
		File file = new File(path);
		String mime = NanoHTTPD.getMimeTypeForFile(file.getName());
		FileInputStream fis;
		try {
			fis = new FileInputStream(file);
		} catch (FileNotFoundException e) {
			System.err.println("Requested file: " + file.getPath() + ", not found.");
			return Response.newFixedLengthResponse("File not Found");
		}
		return Response.newFixedLengthResponse(Status.OK, mime, fis, file.length());
	}

	public Response redirect(String uri) {
		return Response.newFixedLengthResponse("<script>window.location.replace(\"" + uri + "\");</script>");
	}

	public Response ss(String msg) {
		return Response.newFixedLengthResponse(msg);
	}

	public static void main(String[] args) {
		int port = 0;
		if (args.length == 1) {
			port = Integer.parseInt(args[0]);
		} else {
			port = 8080;
		}
		App app = new App(port);
		System.out.println("Starting server...");
		try {
			app.start(NanoHTTPD.SOCKET_READ_TIMEOUT, false);
		} catch (IOException e) {
			System.err.println("Couldn't start server.");
			e.printStackTrace();
		}
	}

	public Template getTemplate(String path) {
		try {
			return new Template(getFile(path));
		} catch (IOException e) {
			System.err.println("Could not open file at path " + path);
			e.printStackTrace();
		}
		return new Template("Could not open file");
	}

	public String getFile(String path) throws IOException {
		return new String(Files.readAllBytes(Paths.get(path)), StandardCharsets.UTF_8);
	}
}
